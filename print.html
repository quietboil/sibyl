<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sibyl User Manual</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="using.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="env.html"><strong aria-hidden="true">2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="conn.html"><strong aria-hidden="true">3.</strong> Connections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conn_own.html"><strong aria-hidden="true">3.1.</strong> Connection Per Thread</a></li><li class="chapter-item expanded "><a href="session_pool.html"><strong aria-hidden="true">3.2.</strong> Session Pool</a></li><li class="chapter-item expanded "><a href="conn_pool.html"><strong aria-hidden="true">3.3.</strong> Connection Pool</a></li></ol></li><li class="chapter-item expanded "><a href="exec.html"><strong aria-hidden="true">4.</strong> SQL Statement Execution</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="odt.html"><strong aria-hidden="true">5.</strong> Oracle Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="odt/varchar.html"><strong aria-hidden="true">5.1.</strong> Varchar</a></li><li class="chapter-item expanded "><a href="odt/number.html"><strong aria-hidden="true">5.2.</strong> Number</a></li><li class="chapter-item expanded "><a href="odt/raw.html"><strong aria-hidden="true">5.3.</strong> RAW</a></li><li class="chapter-item expanded "><a href="odt/date.html"><strong aria-hidden="true">5.4.</strong> Date</a></li><li class="chapter-item expanded "><a href="odt/timestamp.html"><strong aria-hidden="true">5.5.</strong> Timestamp</a></li><li class="chapter-item expanded "><a href="odt/interval.html"><strong aria-hidden="true">5.6.</strong> Interval</a></li><li class="chapter-item expanded "><a href="odt/rowid.html"><strong aria-hidden="true">5.7.</strong> Row ID</a></li><li class="chapter-item expanded "><a href="odt/cursor.html"><strong aria-hidden="true">5.8.</strong> Cursor</a></li><li class="chapter-item expanded "><a href="odt/lobs.html"><strong aria-hidden="true">5.9.</strong> LOB</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Notes</li><li class="chapter-item expanded "><a href="issues.html"><strong aria-hidden="true">6.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="limits.html"><strong aria-hidden="true">7.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">8.</strong> Testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sibyl User Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/quietboil/sibyl" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Sibyl is an <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/lnoci/index.html">OCI</a>-based interface (a.k.a. a driver) between Rust applications and Oracle databases. It supports both sync (blocking) and async (nonblocking) API.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Assuming an <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/comsc/installing-sample-schemas.html#GUID-1E645D09-F91F-4BA6-A286-57C5EC66321D">HR sample schema</a> is installed, the following example program would report median salaries for each country in the specified region.</p>
<h3 id="bloking-mode-version"><a class="header" href="#bloking-mode-version">Bloking Mode Version</a></h3>
<pre><code class="language-rust noplayground">fn main() -&gt; sibyl::Result&lt;()&gt; {
    let oracle = sibyl::env()?;

    let dbname = std::env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = std::env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = std::env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    let session = oracle.connect(&amp;dbname, &amp;dbuser, &amp;dbpass)?;

    let stmt = session.prepare(&quot;
        SELECT c.country_name, Median(e.salary)
          FROM hr.employees e
          JOIN hr.departments d ON d.department_id = e.department_id
          JOIN hr.locations l   ON l.location_id = d.location_id
          JOIN hr.countries c   ON c.country_id = l.country_id
          JOIN hr.regions r     ON r.region_id = c.region_id
         WHERE r.region_name = :REGION_NAME
      GROUP BY c.country_name
    &quot;)?;

    let rows = stmt.query(&quot;Europe&quot;)?;

    while let Some(row) = rows.next()? {
        let country_name : &amp;str = row.get_not_null(0)?;
        let median_salary : u16 = row.get_not_null(1)?;
        println!(&quot;{:25}: {:&gt;5}&quot;, country_name, median_salary);
    }
    Ok(())
}
</code></pre>
<p>When executed it prints:</p>
<pre><code class="language-plaintext">Germany                  : 10000
United Kingdom           :  8800
</code></pre>
<h3 id="nonblocking-async-mode-version"><a class="header" href="#nonblocking-async-mode-version">Nonblocking (async) Mode Version</a></h3>
<pre><code class="language-rust noplayground">fn main() -&gt; sibyl::Result&lt;()&gt; {
  sibyl::block_on(async {
    let oracle = sibyl::env()?;

    let dbname = std::env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = std::env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = std::env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    let session = oracle.connect(&amp;dbname, &amp;dbuser, &amp;dbpass).await?;

    let stmt = session.prepare(&quot;
        SELECT c.country_name, Median(e.salary)
          FROM hr.employees e
          JOIN hr.departments d ON d.department_id = e.department_id
          JOIN hr.locations l   ON l.location_id = d.location_id
          JOIN hr.countries c   ON c.country_id = l.country_id
          JOIN hr.regions r     ON r.region_id = c.region_id
         WHERE r.region_name = :REGION_NAME
      GROUP BY c.country_name
    &quot;).await?;

    let rows = stmt.query(&quot;Europe&quot;).await?;

    while let Some(row) = rows.next().await? {
        let country_name : &amp;str = row.get_not_null(0)?;
        let median_salary : u16 = row.get_not_null(1)?;
        println!(&quot;{:25}: {:&gt;5}&quot;, country_name, median_salary);
    }
    Ok(())
  })
}
</code></pre>
<blockquote>
<p>Note the only difference between this and the blocking mode program is that <code>async</code> method calls need to be <code>await</code>ed. Otherwise the <code>async</code> version of the program is a verbatim copy of the non-async one.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>Sibyl needs an installed Oracle client in order to link either <code>OCI.DLL</code> on Windows or <code>libclntsh.so</code> on Linux. The minimal supported client is 12.2 as Sibyl uses some API functions that are not available in earlier clients.</p>
<blockquote>
<p><em>Note</em> that while suporting 12.1 and older clients is definitely feasible, it was not a priority.</p>
</blockquote>
<h1 id="using-sibyl-in-a-project"><a class="header" href="#using-sibyl-in-a-project">Using Sibyl In A Project</a></h1>
<p>Sibyl has 2 features - <code>blocking</code> and <code>nonblocking</code>. They are <strong>exclusive</strong> and <strong>one</strong> must be explictly selected as neither is the default. Thus, when Sibyl is used as a dependency, it might be included as:</p>
<pre><code class="language-toml">[dependencies]
sibyl = { version = &quot;0.6&quot;, features = [&quot;blocking&quot;] }
</code></pre>
<p>A <code>nonblocking</code> mode also needs to know which async runtime/executor it is allowed to use to spawn async tasks. The async runtime selection is also controled by a set of exclusive features. For now, Sibyl supports <code>tokio</code>, <code>actix</code>, <code>async-std</code>, and <code>async-global</code>. One of these must be specified with the <code>nonblocking</code> feature. For example:</p>
<pre><code class="language-toml">[dependencies]
sibyl = { version = &quot;0.6&quot;, features = [&quot;nonblocking&quot;, &quot;tokio&quot;] }
</code></pre>
<h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>The cargo build needs to know where the OCI client library is. You can provide that information via environment variable <code>OCI_LIB_DIR</code> on Windows or <code>LIBRARY_PATH</code> on Linux. On Linux <code>LIBRARY_PATH</code> would include the path to the <code>lib</code> directory with <code>libclntsh.so</code>. For example, you might build Sibyl's examples as:</p>
<pre><code class="language-shell">export LIBRARY_PATH=/usr/lib/oracle/19.13/client64/lib
cargo build --examples --features=blocking
</code></pre>
<p>On Windows the process is similar if the target environment is <code>gnu</code>. The <code>OCI_LIB_DIR</code> would point to the directory with <code>oci.dll</code>:</p>
<pre><code class="language-plaintext">set OCI_LIB_DIR=%ORACLE_HOME%\bin
cargo build --examples --features=blocking
</code></pre>
<p>However, for <code>msvc</code> environment the <code>OCI_LIB_DIR</code> must point to the directory with <code>oci.lib</code>. For example, you might build those examples as:</p>
<pre><code class="language-plaintext">set OCI_LIB_DIR=%ORACLE_HOME%\oci\lib\msvc
cargo build --examples --features=blocking
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment"><a class="header" href="#environment">Environment</a></h1>
<p>An OCI environment handle must be created before any other OCI function can be called. While there can be many environments - for example, they might be configured to have different languages and territories - usually one is sufficient. Sibyl initializes it to be the most compatible with Rust requirements - thread-safe using UTF8 (AL32UTF8) character encoding. That single environment handle can be created in <code>main</code> and then passed around:</p>
<pre><code class="language-rust ignore">fn main() {
    let oracle = sibyl::env().expect(&quot;Oracle OCI environment&quot;);
    // ...
}
</code></pre>
<p>Note however that some functions will need a direct reference to this handle, so instead of passing it around some applications might prefer to create it statically:</p>
<pre><code class="language-rust ignore">use sibyl::Environment;
use lazy_static::lazy_static;

lazy_static!{
    pub static ref ORACLE : Environment = sibyl::env().expect(&quot;Oracle OCI environment&quot;);
}
</code></pre>
<p>Then later one would be able to create, for example, a current timestamp as:</p>
<pre><code class="language-rust ignore">use sibyl::TimestampTZ;

let current_timestamp = TimestampTZ::from_systimestamp(&amp;ORACLE)?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connections"><a class="header" href="#connections">Connections</a></h1>
<p>Depending on the application and its needs there are several ways to obtain a database sesssion:</p>
<ul>
<li>An application might use <code>Environment::connect</code> method to connect to a database and start a new user session. This is the most relevant way to get session for a single threaded application. Though, multithreaded applications might, in some cases, do the same.</li>
<li>A multithreaded or a multitasking (async) application might create a session pool and then make each thread (or task) &quot;borrow&quot; a session from that pool for limited time. The caveat here is that those sessions are indistinguishable and thus must be &quot;stateless&quot;.</li>
<li>A blocking mode multithreaded application might create a connection pool and make each thread establish their own sessions that would use pooled connections when they need to communicate with the database. As these sessions are not shared, they can be &quot;stateful&quot;.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-per-thread"><a class="header" href="#connection-per-thread">Connection Per Thread</a></h1>
<pre><code class="language-rust noplayground">fn main() -&gt; sibyl::Result&lt;()&gt; {
    let oracle = sibyl::env()?;

    let dbname = std::env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = std::env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = std::env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    let session = oracle.connect(&amp;dbname, &amp;dbuser, &amp;dbpass)?;
    // ...
    Ok(())
}
</code></pre>
<p>Where <code>dbname</code> can be any name that is acceptable to Oracle clients - from local TNS name to EZConnect identifier to a connect descriptor.</p>
<p>Or with multiple threads:</p>
<pre><code class="language-rust noplayground">use std::{env, thread, sync::Arc};
use sibyl::*;

fn main() -&gt; Result&lt;()&gt; {
    let oracle = sibyl::env()?;
    let oracle = Arc::new(oracle);

    let mut workers = Vec::new();
    for _i in 0..10 {
        let oracle = oracle.clone();
        let handle = thread::spawn(move || -&gt; Result&lt;()&gt; {
            let dbname = env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
            let dbuser = env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
            let dbpass = env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

            let session = oracle.connect(&amp;dbname, &amp;dbuser, &amp;dbpass)?;            
            // ...
            Ok(())
        }
        workers.push(handle);
    }
    for handle in workers {
        let _ = handle.join();
    }
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-pool"><a class="header" href="#session-pool">Session Pool</a></h1>
<p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/lnoci/session-and-connection-pooling.html#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C">Session pool</a> can be used in both <code>blocking</code> and <code>nonblocking</code> mode applicaitons.</p>
<h2 id="blocking-mode-pool"><a class="header" href="#blocking-mode-pool">Blocking Mode Pool</a></h2>
<pre><code class="language-rust noplayground">use std::{env, thread, sync::Arc};
use once_cell::sync::OnceCell;
use sibyl::*;

fn main() -&gt; sibyl::Result&lt;()&gt; {
    static ORACLE : OnceCell&lt;Environment&gt; = OnceCell::new();
    let oracle = ORACLE.get_or_try_init(|| {
        Environment::new()
    })?;

    let dbname = env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    // All sessions will be authenticated with the provided user name and password.
    let pool = oracle.create_session_pool(&amp;dbname, &amp;dbuser, &amp;dbpass, 0, 1, 10)?;
    // This pool has 0 available session at this time, will create 1 session at a
    // time when they are needed (session is requested and there are no available
    // sessions in the pool), up to the maximum of 10 sessions.
    let pool = Arc::new(pool);

    let mut workers = Vec::new();
    for _i in 0..100 {
        let pool = pool.clone();
        let handle = thread::spawn(move || -&gt; Result&lt;()&gt; {
            let session = pool.get_session()?;
            // ...
            Ok(())
        }
        workers.push(handle);
    }
    for handle in workers {
        let _ = handle.join();
    }
    Ok(())
}
</code></pre>
<h2 id="nonblocking-mode-pool"><a class="header" href="#nonblocking-mode-pool">Nonblocking Mode Pool</a></h2>
<pre><code class="language-rust noplayground">use std::{env, thread, sync::Arc};
use once_cell::sync::OnceCell;
use sibyl::*;

#[tokio::main]
async fn main() -&gt; sibyl::Result&lt;()&gt; {
    static ORACLE : OnceCell&lt;Environment&gt; = OnceCell::new();
    let oracle = ORACLE.get_or_try_init(|| {
        Environment::new()
    })?;

    let dbname = env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    let pool = oracle.create_session_pool(&amp;dbname, &amp;dbuser, &amp;dbpass, 0, 1, 10).await?;
    let pool = Arc::new(pool);

    let mut workers = Vec::new();
    for _i in 0..100 {
        let pool = pool.clone();
        let handle = tokio::task::spawn(async move {
            let session = pool.get_session().await?;
            // ...
            Ok::&lt;_,Error&gt;(())
        }
        workers.push(handle);
    }
    for handle in workers {
        let _ = handle.await;
    }
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-pool"><a class="header" href="#connection-pool">Connection Pool</a></h1>
<p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/lnoci/session-and-connection-pooling.html#GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683">Connection pool</a> can only be used in <code>blocking</code> mode applications.</p>
<pre><code class="language-rust noplayground">use std::{env, thread, sync::Arc};
use once_cell::sync::OnceCell;
use sibyl::*;

fn main() -&gt; sibyl::Result&lt;()&gt; {
    static ORACLE : OnceCell&lt;Environment&gt; = OnceCell::new();
    let oracle = ORACLE.get_or_try_init(|| {
        Environment::new()
    })?;

    let dbname = env::var(&quot;DBNAME&quot;).expect(&quot;database name&quot;);
    let dbuser = env::var(&quot;DBUSER&quot;).expect(&quot;user name&quot;);
    let dbpass = env::var(&quot;DBPASS&quot;).expect(&quot;password&quot;);

    // Connection pool needs to establish an internal session with the database.
    // `dbuser` and `dbpass` here are for that session.
    let pool = oracle.create_connection_pool(&amp;dbname, &amp;dbuser, &amp;dbpass, 0, 1, 4)?;
    // This pool has 0 available connections at this time, will create 1 connection
    // at a time when they are needed (session needs a connection to run and there
    // are no available connections in the pool), up to the maximum of 4 connections.
    let pool = Arc::new(pool);

    let mut workers = Vec::new();
    for i in 0..10 {
        let pool = pool.clone();
        let handle = thread::spawn(move || -&gt; Result&lt;()&gt; {
            let dbuser = env::var(format!(&quot;DBUSER{}&quot;,i)).expect(&quot;user name&quot;);
            let dbpass = env::var(format!(&quot;DBPASS{}&quot;,i)).expect(&quot;password&quot;);
            // Here `dbuser` and `dbpass` are used to create a new database session.
            // While these sessions share pooled connections, they are entirely
            // &quot;owned&quot; by the threads that created them and as such might use
            // different users for authentication.
            let session = pool.get_session(&amp;dbuser, &amp;dbpass)?;
            // ...
            Ok(())
        }
        workers.push(handle);
    }
    for handle in workers {
        let _ = handle.join();
    }
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-statement-execution"><a class="header" href="#sql-statement-execution">SQL Statement Execution</a></h1>
<p>All SQL or PL/SQL statements must be prepared before they can be executed:</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    SELECT employee_id, last_name, first_name
      FROM hr.employees
     WHERE manager_id = :id
  ORDER BY employee_id
&quot;)?;
</code></pre>
<p>A prepared statement can be executed either with the <code>query</code>, <code>query_single</code> or <code>execute</code> methods:</p>
<ul>
<li><code>query</code> is used for <code>SELECT</code> statements. In fact, Sibyl will complain if you try to <code>query</code> any other statement.</li>
<li><code>query_single</code> is a variant of <code>query</code> that returns a single row. It's a convenience method that allows skipping boilerplate of extrating only one row from a result set when it is known upfront that only one row (or none) is expected.</li>
<li><code>execute</code> is used for all other, non-SELECT, DML and DDL.</li>
</ul>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p><code>query</code>, <code>query_single</code> and <code>execute</code> take a tuple of arguments (or a single argument). The latter can be specified as positional arguments or as name-value tuples. For example, to execute the above SELECT we can call <code>query</code> using a positional argument as:</p>
<pre><code class="language-rust ignore">let row = stmt.query_single(103)?;
</code></pre>
<p>or bind a value to <code>:id</code> by name as:</p>
<pre><code class="language-rust ignore">let row = stmt.query_single((&quot;:ID&quot;, 103))?;
</code></pre>
<p>In most cases which binding style to use is a matter of convenience and/or personal preferences. However, in some cases named arguments would be preferable and less ambiguous. For example, statement might change during development and thus force the change in argument positions. Also SQL and PL/SQL statements have different interpretation of a parameter position. SQL statements create positions for every parameter but allow a single argument to be used for the primary parameter and all its duplicares. PL/SQL on the other hand creates positions for unique parameter names and this might make positioning arguments correctly a bit awkward when there is more than one &quot;duplicate&quot; name in a statement.</p>
<blockquote>
<p>Note one caveat - until <a href="https://doc.rust-lang.org/stable/unstable-book/language-features/min-specialization.html#min_specialization">min_specialization</a> is stabilized Sibyl has no way of distinguishing whether a 2-item tuple is used to pass a single named argument or 2 positional arguments. For the moment you must use a 3-item tuple with a unit type as the last item when you are passing 2 positional arguments. The unit type is skipped, so effectively only first 2 arguments are used. For example:</p>
</blockquote>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    SELECT department_id, manager_id
      FROM hr.departments
     WHERE department_name = :DEPARTMENT_NAME
       AND location_id = :LOCATION_ID
&quot;)?;
let rows = stmt.query(( &quot;Administration&quot;, 1700, () ))?;
</code></pre>
<p><code>execute</code> also allows execution of statements with OUT (or INOUT) parameters. For example:</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    INSERT INTO hr.departments
           ( department_id, department_name, manager_id, location_id )
    VALUES ( hr.departments_seq.nextval, :department_name, :manager_id, :location_id )
 RETURNING department_id
      INTO :department_id
&quot;)?;
let mut department_id: u32 = 0;
let num_inserted = stmt.execute(
    (
        (&quot;:DEPARTMENT_NAME&quot;, &quot;Security&quot;         ),
        (&quot;:MANAGER_ID&quot;,      &quot;&quot;                 ),
        (&quot;:LOCATION_ID&quot;,     1700               ),
        (&quot;:DEPARTMENT_ID&quot;,   &amp;mut department_id ),
    )
)?;
</code></pre>
<p><code>execute</code> returns the number of rows affected by the statement. <code>query</code> returns what is colloquially called a &quot;streaming iterator&quot; which is typically iterated using <code>while</code>. For example (continuing the SELECT example from above):</p>
<pre><code class="language-rust ignore">let mut employees = HashMap::new();
let stmt = session.prepare(&quot;
    SELECT employee_id, last_name, first_name
      FROM hr.employees
     WHERE manager_id = :id
  ORDER BY employee_id
&quot;)?;
let rows = stmt.query(103)?;
while let Some( row ) = rows.next()? {
    let employee_id : u32 = row.get_not_null(0)?;
    let last_name : &amp;str  = row.get_not_null(1)?;
    let first_name : Option&lt;&amp;str&gt; = row.get(2)?;
    let name = first_name.map_or(last_name.to_string(),
        |first_name| format!(&quot;{}, {}&quot;, last_name, first_name)
    );
    employees.insert(employee_id, name);
}
</code></pre>
<p>There are a few notable points of interest in the last example:</p>
<ul>
<li>Sibyl uses 0-based column indexing in a projection.</li>
<li><code>LAST_NAME</code> and <code>FIRST_NAME</code> are retrieved as <code>&amp;str</code>. This is fast as they borrow directly from the respective column buffers. However, those values will only be valid during the lifetime of the row. If the value needs to continue to exist beyond the lifetime of a row, it should be retrieved as a <code>String</code>.</li>
</ul>
<blockquote>
<p>Note that while Sibyl expects 0-based indexes to reference projection columns, it also accepts column names. Thus, the row processing loop of the previous example can be written as:</p>
</blockquote>
<pre><code class="language-rust ignore">while let Some( row ) = rows.next()? {
    let employee_id : u32 = row.get_not_null(&quot;EMPLOYEE_ID&quot;)?;
    let last_name : &amp;str  = row.get_not_null(&quot;LAST_NAME&quot;)?;
    let first_name : Option&lt;&amp;str&gt; = row.get(&quot;FIRST_NAME&quot;)?;
    let name = first_name.map_or(last_name.to_string(),
        |first_name| format!(&quot;{}, {}&quot;, last_name, first_name)
    );
    employees.insert(employee_id, name);
}
</code></pre>
<p><strong>Note</strong> that all examples use all upper case column and parameter names. This is not really necessary as Sibyl treat them as case-insensitive. However, using all upper case gives Sibyl a chance to locate a column (or a parameter placeholder) without converting the name to upper case first (to match the Oracle reported names), thus avoiding temporary string allocation and upper case conversion. Of course, you can always maintain an <code>enum</code> for a select list, thus using indexes, which are the speediest way to get to the data anyway.</p>
<pre><code class="language-rust ignore">enum Col { EmployeeId, LastName, FirstName }

while let Some( row ) = rows.next()? {
    let employee_id : u32 = row.get_not_null(Col::EmployeeId as usize)?;
    let last_name : &amp;str  = row.get_not_null(Col::LastName as usize)?;
    let first_name : Option&lt;&amp;str&gt; = row.get(Col::FirstName as usize)?;
    // ...
}
</code></pre>
<p>Or to be extra fancy:</p>
<pre><code class="language-rust ignore">#[derive(Clone,Copy)]
enum Col { EmployeeId, LastName, FirstName }

impl sibyl::Position for Col {
    fn index(&amp;self) -&gt; Option&lt;usize&gt; { Some(*self as _) }
}

impl std::fmt::Display for Col {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        static COLS : [&amp;str;3] = [&quot;EMPLOYEE_ID&quot;, &quot;LAST_NAME&quot;, &quot;FIRST_NAME&quot;];
        let i = *self as usize;
        f.write_str(COLS[i])
    }
}

while let Some( row ) = rows.next()? {
    let employee_id : u32 = row.get_not_null(Col::EmployeeId)?;
    let last_name : &amp;str  = row.get_not_null(Col::LastName)?;
    let first_name : Option&lt;&amp;str&gt; = row.get(Col::FirstName)?;
    // ...
}
</code></pre>
<p>Of couse, that's a lot of boilerplate, which would benefit from a <code>derive</code> macro. Maybe we'll get to that eventually :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle-data-types"><a class="header" href="#oracle-data-types">Oracle Data Types</a></h1>
<p>Sibyl provides API to access several Oracle native data types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="varchar"><a class="header" href="#varchar">VARCHAR</a></h1>
<pre><code class="language-rust noplayground"><span class="boring">fn main() -&gt; sibyl::Result&lt;()&gt; {
</span>use sibyl::Varchar;

let env = sibyl::env()?;

let txt = Varchar::from(&quot;Hello, World!&quot;, &amp;env)?;

assert_eq!(txt.as_str(), &quot;Hello, World!&quot;);
<span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number"><a class="header" href="#number">Number</a></h1>
<pre><code class="language-rust ignore">use sibyl::Number;

let oracle = sibyl::env()?;

let pi = Number::pi(&amp;oracle);
let two = Number::from_int(2, &amp;oracle);
let two_pi = pi.mul(&amp;two)?;
let h = Number::from_string(&quot;6.62607004E-34&quot;, &quot;9D999999999EEEE&quot;, &amp;oracle)?;
let hbar = h.div(&amp;two_pi)?;

assert_eq!(
    hbar.to_string(&quot;TME&quot;)?,
    &quot;1.05457180013911265115394106872506677375E-34&quot;
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw"><a class="header" href="#raw">RAW</a></h1>
<pre><code class="language-rust noplayground"><span class="boring">fn main() -&gt; sibyl::Result&lt;()&gt; {
</span>use sibyl::Raw;

let env = sibyl::env()?;

let raw = Raw::from_bytes(&amp;[1u8,2,3,4,5], &amp;env)?;

assert_eq!(raw.as_bytes(), &amp;[1u8,2,3,4,5]);
<span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date"><a class="header" href="#date">Date</a></h1>
<pre><code class="language-rust ignore">use sibyl::Date;

let mar28_1996 = Date::from_string(&quot;28-MAR-1996&quot;, &quot;DD-MON-YYYY&quot;, &amp;oracle)?;
let next_monday = mar28_1996.next_week_day(&quot;MONDAY&quot;)?;

assert_eq!(next_monday.to_string(&quot;DL&quot;)?, &quot;Monday, April 01, 1996&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h1>
<p>There are 3 types of timestamps:</p>
<ul>
<li><code>Timestamp</code> which is equivalent to Oracle TIMESTAMP data type,</li>
<li><code>TimestampTZ</code> - TIMESTAMP WITH TIME ZONE, and</li>
<li><code>TimestampLTZ</code> - TIMESTAMP WITH LOCAL TIME ZONE</li>
</ul>
<pre><code class="language-rust ignore">use sibyl::TimestampTZ;

let ts = oracle::TimestampTZ::from_string(
    &quot;July 20, 1969 8:18:04.16 pm UTC&quot;,
    &quot;MONTH DD, YYYY HH:MI:SS.FF PM TZR&quot;,
    &amp;oracle
)?;
assert_eq!(
    ts.to_string(&quot;YYYY-MM-DD HH24:MI:SS.FF TZR&quot;, 3)?,
    &quot;1969-07-20 20:18:04.160 UTC&quot;
);
</code></pre>
<blockquote>
<p>Note that if you are getting <code>ORA-01805</code> when timestamp with time zone is used, then most likely your local client and the server it is connected to are using different versions of the time zone file. This <a href="https://stackoverflow.com/questions/69381749/where-is-the-oracle-instant-client-timezone-file-located">stackoverflow answer</a> should help you in setting up your local client with the correct time zone file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interval"><a class="header" href="#interval">Interval</a></h1>
<p>There are 2 types of intervals:</p>
<ul>
<li><code>IntervalYM</code> which is eqivalent to Oracle's INTERVAL YEAR TO MONTH,</li>
<li><code>IntervalDS</code> - INTERVAL DAY TO SECOND</li>
</ul>
<pre><code class="language-rust ignore">use sibyl::{ TimestampTZ, IntervalDS };

let launch  = TimestampTZ::with_date_and_time(1969, 7, 16, 13, 32,  0, 0, &quot;UTC&quot;, &amp;oracle)?;
let landing = TimestampTZ::with_date_and_time(1969, 7, 24, 16, 50, 35, 0, &quot;UTC&quot;, &amp;oracle)?;
let duration : IntervalDS = landing.subtract(&amp;launch)?;

assert_eq!(duration.to_string(1,3)?, &quot;+8 03:18:35.000&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="row-id"><a class="header" href="#row-id">Row ID</a></h1>
<p>Oracle ROWID can be selected and retrieved explicitly into an instance of the <code>RowID</code>. However, one interesting case is SELECT FOR UPDATE queries where Oracle returns ROWIDs implicitly. Those can be retrieved using <code>Row::rowid</code> method.</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    SELECT manager_id
      FROM hr.employees
     WHERE employee_id = :id
       FOR UPDATE
&quot;)?;
let row = stmt.query_single(107)?;
let rowid = row.rowid()?;

let manager_id: u32 = row.get_not_null(0)?;
assert_eq!(manager_id, 103);

let stmt = session.prepare(&quot;
    UPDATE hr.employees
       SET manager_id = :manager_id
     WHERE rowid = :row_id
&quot;)?;
let num_updated = stmt.execute((
    ( &quot;:MANAGER_ID&quot;, 102 ),
    ( &quot;:ROW_ID&quot;,  &amp;rowid ),
))?;
assert_eq!(num_updated, 1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor"><a class="header" href="#cursor">Cursor</a></h1>
<p>Cursors can be returned explicitly:</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    BEGIN
        OPEN :emp FOR
            SELECT department_name, first_name, last_name, salary
              FROM hr.employees e
              JOIN hr.departments d
                ON d.department_id = e.department_id;
    END;
&quot;)?;
let mut cursor = Cursor::new(&amp;stmt)?;
stmt.execute(&amp;mut cursor)?;
let rows = cursor.rows()?;
// ...
</code></pre>
<p>Or, beginning with Oracle 12.1, implicitly:</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    DECLARE
        emp SYS_REFCURSOR;
    BEGIN
        OPEN emp FOR
            SELECT department_name, first_name, last_name, salary
              FROM hr.employees e
              JOIN hr.departments d
                ON d.department_id = e.department_id;
        ;
        DBMS_SQL.RETURN_RESULT(emp);
    END;
&quot;)?;
stmt.execute(())?;
if let Some( cursor ) = stmt.next_result()? {
    let rows = cursor.rows()?;
    // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clobs-blobs-bfiles"><a class="header" href="#clobs-blobs-bfiles">CLOBs, BLOBs, BFILEs</a></h1>
<p>Let's assume a table was created:</p>
<pre><code class="language-sql">CREATE TABLE lob_example (
    id  NUMBER GENERATED ALWAYS AS IDENTITY,
    bin BLOB
);
</code></pre>
<p>We can then create and write data into that LOB as:</p>
<pre><code class="language-rust ignore">// ... create OCI environment, connect to the database, etc.

let file = BFile::new(&amp;session)?;
file.set_file_name(&quot;MEDIA_DIR&quot;, &quot;mousepad_comp_ad.pdf&quot;)?;
let file_len = file.len()?;

file.open_file()?;
let mut data = Vec::new();
let num_read = file.read(0, file_len, &amp;mut data)?;
file.close_file()?;
// ... or do not close now as it will be closed
// automatically when `file` goes out of scope

// Insert new BLOB and lock its row
let stmt = session.prepare(&quot;
    DECLARE
        row_id ROWID;
    BEGIN
        INSERT INTO lob_example (bin) VALUES (Empty_Blob()) RETURNING rowid INTO row_id;
        SELECT bin INTO :NEW_BLOB FROM lob_example WHERE rowid = row_id FOR UPDATE;
    END;
&quot;)?;
let mut lob = BLOB::new(&amp;session)?;
stmt.execute(&amp;mut lob)?;

lob.open()?;
let num_bytes_written = lob.write(0, &amp;data)?;
lob.close()?;

session.commit()?;
</code></pre>
<p>And then later it could be read as:</p>
<pre><code class="language-rust ignore">let id: usize = 1234; // assume it was retrieved from somewhere...
let stmt = session.prepare(&quot;SELECT bin FROM lob_example WHERE id = :ID&quot;)?;
let row = stmt.query_single(&amp;id)?;
if let Some(row) = row {
    if let Some(lob) = row.get(0)? {
        let data = read_blob(lob)?;
        // ...
    }
}

// Where `read_blob` could be this:
fn read_blob(lob: BLOB&lt;'_&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let mut data = Vec::new();
    let lob_len = lob.len()?;
    let offset = 0;
    lob.read(offset, lob_len, &amp;mut data)?;
    Ok(data)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-with-some-clients"><a class="header" href="#known-issues-with-some-clients">Known Issues with Some Clients</a></h1>
<p>12.2 client does not support <code>OCI_ATTR_SPOOL_MAX_USE_SESSION</code> and thus <code>SessionPool</code>'s <code>session_max_use_count</code> and <code>set_session_max_use_count</code> will fail on it with <code>ORA-24315: illegal attribute type</code>.</p>
<p>21.4 client (at least with 19.3 database) is strangely picky about names of parameter placeholders for LOB columns. For example, if a table was created with the following LOB column:</p>
<pre><code class="language-sql">CREATE TABLE table_with_lob (
    id   NUMBER GENERATED ALWAYS AS IDENTITY,
    txt  CLOB
);
</code></pre>
<p>and if an SQL parameter name is the same as the LOB column name (as in this example):</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    INSERT INTO table_with_lob (txt) VALUES (:TXT) RETURNING id INTO :ID
&quot;)?;
</code></pre>
<p>Then 21.4 client will fail executing this SQL with <code>ORA-03120: two-task conversion routine: integer overflow</code>. Renaming the parameter placeholder resolves this:</p>
<pre><code class="language-rust ignore">let stmt = session.prepare(&quot;
    INSERT INTO table_with_lob (txt) VALUES (:NEW_TXT) RETURNING id INTO :ID
&quot;)?;
</code></pre>
<p>21.4 also does not &quot;like&quot; some specific parameter names like <code>:NAME</code> which makes it fail with the same <code>ORA-03120</code>.</p>
<blockquote>
<p>Note that 12.2 through 19.13 clients (as far as Sibyl's tests showed) do not exhibit this issue.</p>
</blockquote>
<p>21.4 client (at least when it is connected to the 19.3 database) cannot read <strong>CLOBs</strong> piece-wize - something bad happens in <code>OCILobRead2</code> as it reads the last piece and the process gets killed. 21.4 client has no issues executing piece-wise reads from BFILEs and BLOBs.</p>
<p>All tested clients behave erratically in <code>nonblocking</code> mode when they execute piece-wize LOB operations. Therefore, in <code>nonblocking</code> mode Sibyl does not support LOBs piece-wise reading and writing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<p>At this time Sibyl provides only the most commonly needed means to interface with the Oracle database. Some of the missing features are:</p>
<ul>
<li>Array interface for multi-row operations</li>
<li>User defined data types</li>
<li>PL/SQL collections and tables</li>
<li>Objects</li>
<li>JSON data</li>
<li>LDAP and proxy authentications</li>
<li>Global transactions</li>
<li>High Availability</li>
<li>Continuous query and publish-subscribe notifications</li>
<li>Advanced queuing</li>
<li>Shards</li>
<li>Direct path load</li>
</ul>
<p>Some of these features might be added in the upcoming releases if the need arises or if they are explicitly requested. Some, however, will never be implemented. The latter category includes those that are incompatible with nonblocking execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Some of Sibyl's tests connect to the database and expect certain objects to exist in it and certain privileges granted:</p>
<ul>
<li>At least the HR demo schema should be <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/comsc/installing-sample-schemas.html#GUID-1E645D09-F91F-4BA6-A286-57C5EC66321D">installed</a>.</li>
<li>While there is no need to install other demo schemas at least <code>MEDIA_DIR</code> should be created (see <code>$ORACLE_HOME/demo/schema/mk_dir.sql</code>) and point to the directory with demo files. The latter can be found in <code>product_media</code> in the <a href="https://github.com/oracle/db-sample-schemas/releases/latest">db-sample-schemas.zip</a>.</li>
<li>Some of the LOB tests need text files with the the expected content. Those can be found in <code>etc/media</code> and copied into <code>MEDIA_DIR</code>.</li>
<li>A test user should be created. That user needs acccess to the HR schema and to the <code>MEDIA_DIR</code> directory. See <code>etc/create_sandbox.sql</code> for an example of how it can be accomplished.</li>
<li>Tests that connect to the database use environment variables - <code>DBNAME</code>, <code>DBUSER</code> and <code>DBPASS</code> - to identify the database, user and password respectively. These variables should be set before executing <code>cargo test</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
